(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{792:function(_,v,t){"use strict";t.r(v);var a=t(41),s=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1、执行环境栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、执行环境栈"}},[_._v("#")]),_._v(" 1、执行环境栈")]),_._v(" "),v("p",[_._v("  浏览器会提供一个供代码运行的环境 "),v("strong",[_._v("栈内存 ECStack(Execution Context Stack)")]),_._v(",是计算机在计算机中分配出来的一块内存。js代码在执行过程中会按照以下顺序执行。")]),_._v(" "),v("ul",[v("li",[_._v("执行环境栈 "),v("code",[_._v("ECStack")])]),_._v(" "),v("li",[_._v("全局执行上下文"),v("code",[_._v("EC(G)")])]),_._v(" "),v("li",[_._v("全局变量对象 "),v("code",[_._v("VO(G)")])]),_._v(" "),v("li",[_._v("变量对象 "),v("code",[_._v("VO")])]),_._v(" "),v("li",[_._v("活动对象 "),v("code",[_._v("AO")])])]),_._v(" "),v("p",[_._v("基本数据类型赋值的详细过程 "),v("code",[_._v("var a=12")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("创建")]),_._v("一个值12，把它存储起来(基本类型值存在栈内存中)")]),_._v(" "),v("li",[v("strong",[_._v("声明")]),_._v("一个变量("),v("code",[_._v("var a")]),_._v(")，把它存储在当前上下文所属的变量对象中。")]),_._v(" "),v("li",[_._v("最后进行等号"),v("strong",[_._v("赋值")]),_._v("(定义)。本质是一个指针指向的过程。")])]),_._v(" "),v("p",[_._v("引用数据类型赋值的详细过程。"),v("code",[_._v("var a={}")])]),_._v(" "),v("ul",[v("li",[_._v("在计算机中开辟一个堆内存，用来存储自己的键值对，每一个堆内存都有一个16进制的地址。")]),_._v(" "),v("li",[_._v("在堆内存中分别存储键值对。")]),_._v(" "),v("li",[_._v("将16进制的地址放到栈中，供变量调用。")])]),_._v(" "),v("h2",{attrs:{id:"_2、gc-浏览器垃圾回收机制-内存释放机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、gc-浏览器垃圾回收机制-内存释放机制"}},[_._v("#")]),_._v(" 2、GC 浏览器垃圾回收机制 (内存释放机制)")]),_._v(" "),v("h4",{attrs:{id:"_1、栈内存-ec"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、栈内存-ec"}},[_._v("#")]),_._v(" 1、栈内存：EC")]),_._v(" "),v("ul",[v("li",[_._v("全局执行上下文：在浏览器加载页面的时候形成，然后在页面关闭的时候释放。（页面刷新：先释放，重新加载后形成）")]),_._v(" "),v("li",[_._v("私有上下文：函数执行会形成一个私有的上下文(let/const 也会产生私有的上下文)\n"),v("ul",[v("li",[_._v("一般情况下代码执行完就会被出栈释放")]),_._v(" "),v("li",[_._v("如果当前上下文中的某个内容（一般是一个堆）被上下文以外的事物占用了，则当前上下文不能释放。")])])])]),_._v(" "),v("h4",{attrs:{id:"_2、堆内存-heap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、堆内存-heap"}},[_._v("#")]),_._v(" 2、堆内存 ：HEAP")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("谷歌浏览器按照"),v("strong",[_._v("是否被引用")]),_._v(" 来决定堆内存的释放还是不释放的：浏览器回定期间隔一段时间，查找所有堆内存是否被占用，被占用的不处理，但是如果被占用，则直接把它释放掉。（"),v("strong",[_._v("引用计数")]),_._v("）。我们可以手动赋值为"),v("code",[_._v("null")]),_._v(" 的方式，来释放内存。")])]),_._v(" "),v("li",[v("p",[_._v("IE浏览器时根据"),v("strong",[_._v("引用计数")]),_._v("的方式来实现垃圾回收的：每次被占用都会计数累加，相反取消引用，则计数递减。直到计数为0，则释放内存。但是这种方式会出现急着记着就会乱的情况，然后出现 "),v("strong",[_._v("内存泄漏")]),_._v("。")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);