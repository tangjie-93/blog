(window.webpackJsonp=window.webpackJsonp||[]).push([[200],{849:function(t,n,v){"use strict";v.r(n);var _=v(41),l=Object(_.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("最常用的两种方式：")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("射线追踪法")]),t._v("（"),n("code",[t._v("raycasting")]),t._v("）很可能是最常用的方法，其基本原理是：从鼠标处发射一条射线，穿透场景的视椎体，通过计算，找出视锥体中哪些对象与射线相交。\n步骤：")]),t._v(" "),n("li",[t._v("获取鼠标的屏幕坐标.")]),t._v(" "),n("li",[t._v("对其应用摄像机的投影和方向的矩阵变换，得到其在世界空间的坐标。")]),t._v(" "),n("li",[t._v("计算出一条射线，从视锥体的近端平面射向远端平面。再然后，对于场景中每一个对象的每一个三角，检查其是否与射线相交。假设你的场景中有1000个对象，每个对象有1000个三角，那么就需要检查一百万个三角。")])]),t._v(" "),n("p",[t._v("对此，可以做一些优化：先检查对象的包围球或包围盒是否与射线相交。")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("基于GPU的拾取方法")]),t._v("\n需要创建两个场景。一个使用正常的网格对象填充。另外一个使用“拾取材质”的网格对象填充。")])]),t._v(" "),n("Valine")],1)}),[],!1,null,null,null);n.default=l.exports}}]);