(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{539:function(_,v,t){_.exports=t.p+"assets/img/服务端渲染路线.61eac78a.png"},540:function(_,v,t){_.exports=t.p+"assets/img/客户端渲染路线.e2da1cf8.png"},541:function(_,v,t){_.exports=t.p+"assets/img/客户端渲染.7cba1a9f.png"},542:function(_,v,t){_.exports=t.p+"assets/img/服务端渲染.d81cbaa2.png"},886:function(_,v,t){"use strict";t.r(v);var e=t(41),s=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1、什么是服务端渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是服务端渲染"}},[_._v("#")]),_._v(" 1、什么是服务端渲染")]),_._v(" "),v("p",[_._v("将组件或页面通过服务器生成 "),v("code",[_._v("html")]),_._v(' 字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。')]),_._v(" "),v("h3",{attrs:{id:"ssr的优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ssr的优势"}},[_._v("#")]),_._v(" ssr的优势")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("更利于 "),v("code",[_._v("SEO")]),_._v("。\n不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本（ "),v("code",[_._v("Google")]),_._v(" 除外，据说 "),v("code",[_._v("Googlebot")]),_._v(" 可以运行 "),v("code",[_._v("javaScript")]),_._v(" ）。使用了 "),v("code",[_._v("React")]),_._v(" 或者其它 "),v("code",[_._v("MVVM")]),_._v(" 框架之后，页面大多数 "),v("code",[_._v("DOM")]),_._v(" 元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少(如图一)。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行 "),v("code",[_._v("JavaScript")]),_._v(" 脚本的最终 "),v("code",[_._v("HTML")]),_._v("，网络爬中就可以抓取到完整页面的信息。")])]),_._v(" "),v("li",[v("p",[_._v("共用前端代码，节省开发时间")])]),_._v(" "),v("li",[v("p",[_._v("更利于首屏渲染\n首屏的渲染是 "),v("code",[_._v("node")]),_._v(" 发送过来的 "),v("code",[_._v("html")]),_._v(" 字符串，并不依赖于 "),v("code",[_._v("js")]),_._v(" 文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。")])])]),_._v(" "),v("h3",{attrs:{id:"ssr的局限"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ssr的局限"}},[_._v("#")]),_._v(" ssr的局限")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("服务端压力较大\n本来是通过客户端完成渲染，现在统一到服务端 "),v("code",[_._v("node")]),_._v(" 服务去做。尤其是高并发访问的情况，会大量占用服务端 "),v("code",[_._v("CPU")]),_._v(" 资源；")])]),_._v(" "),v("li",[v("p",[_._v("开发条件受限\n在服务端渲染中，"),v("code",[_._v("created")]),_._v(" 和 "),v("code",[_._v("beforeCreate")]),_._v(" 之外的生命周期钩子不可用，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制；")])]),_._v(" "),v("li",[v("p",[_._v("学习成本相对较高\n除了对 "),v("code",[_._v("webpack、Vue")]),_._v(" 要熟悉，还需要掌握 "),v("code",[_._v("node、Koa2")]),_._v(" 等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。")])])]),_._v(" "),v("h2",{attrs:{id:"_2、耗时比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、耗时比较"}},[_._v("#")]),_._v(" 2、耗时比较")]),_._v(" "),v("ul",[v("li",[_._v("数据请求\n由服务端请求首屏数据，而不是客户端请求首屏数据，这是“快”的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。 下图为服务端渲染的数据请求路线和客户端渲染的数据请求路线图。")])]),_._v(" "),v("p",[_._v("服务端渲染路线\n"),v("img",{attrs:{src:t(539),alt:"暂无图片",title:"服务端渲染路线"}})]),_._v(" "),v("p",[_._v("客户端渲染路线\n"),v("img",{attrs:{src:t(540),alt:"暂无图片",title:"客户端渲染路线"}})]),_._v(" "),v("ul",[v("li",[v("code",[_._v("html")]),_._v(" 渲染\n服务端渲染是先向后端服务器请求数据，然后生成完整首屏 "),v("code",[_._v("html")]),_._v(" 返回给浏览器；而客户端渲染是等 "),v("code",[_._v("js")]),_._v(" 代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待 "),v("code",[_._v("js")]),_._v(" 代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。")])]),_._v(" "),v("p",[_._v("客户端渲染\n"),v("img",{attrs:{src:t(541),alt:"暂无图片",title:"客户端渲染"}})]),_._v(" "),v("p",[_._v("服务端渲染\n"),v("img",{attrs:{src:t(542),alt:"暂无图片",title:"服务端渲染"}})]),_._v(" "),v("h2",{attrs:{id:"_3、服务端渲染的使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、服务端渲染的使用场景"}},[_._v("#")]),_._v(" 3、服务端渲染的使用场景")]),_._v(" "),v("p",[_._v("内容丰富，复杂交互的动态网页，对首屏加载有要求的项目，对 "),v("code",[_._v("seo")]),_._v(" 有要求的项目（因为服务端第一次渲染的时候，已经把关键字和标题渲染到响应的 "),v("code",[_._v("html")]),_._v(" 中了，爬虫能够抓取到此静态内容，因此更利于 "),v("code",[_._v("seo")]),_._v("）。此方式一些适合的项目：活动模板，新闻通知类，博客系统，混合开发等等。")])])}),[],!1,null,null,null);v.default=s.exports}}]);