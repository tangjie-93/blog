(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{602:function(_,v,t){_.exports=t.p+"assets/img/坐标系.6afc5317.png"},603:function(_,v,t){_.exports=t.p+"assets/img/坐标系2.10fe3ebc.png"},917:function(_,v,t){"use strict";t.r(v);var e=t(41),o=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[v("code",[_._v("WebGL")]),_._v("的坐标系主要可以分为以下几类。")]),_._v(" "),v("ul",[v("li",[_._v("本地坐标系")]),_._v(" "),v("li",[_._v("世界坐标系")]),_._v(" "),v("li",[_._v("观察坐标系(又称相机坐标系、视图坐标系)")]),_._v(" "),v("li",[_._v("裁剪坐标系("),v("code",[_._v("gl_Position")]),_._v("接收的值)")]),_._v(" "),v("li",[_._v("NDC坐标系")]),_._v(" "),v("li",[_._v("屏幕坐标系")])]),_._v(" "),v("p",[_._v("它们之间的关系如下图所示。"),v("br"),_._v(" "),v("img",{attrs:{width:"800",src:t(602)}}),v("br"),_._v(" "),v("img",{attrs:{width:"800",src:t(603)}}),v("br")]),_._v(" "),v("blockquote",[v("p",[_._v("裁剪坐标系之前的这几个坐标系，我们都可以使用 "),v("code",[_._v("JavaScript")]),_._v(" 控制。从裁剪坐标系到 "),v("code",[_._v("NDC")]),_._v(" 坐标系，这一个步骤是"),v("strong",[_._v("顶点着色器")]),_._v("最后自动完成的，我们无法干预。")])]),_._v(" "),v("h2",{attrs:{id:"_1-本地坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-本地坐标系"}},[_._v("#")]),_._v(" 1.本地坐标系")]),_._v(" "),v("p",[_._v("又称之为"),v("strong",[_._v("模型坐标系")]),_._v("，一个物体通常由很多点构成，每个点在模型的什么位置？我们需要用一个坐标系来参照，这个坐标系就叫本地/模型坐标系，"),v("strong",[_._v("模型坐标系原点通常在模型的中心")]),_._v("，各个坐标轴遵循右手坐标系，即 X 轴向右，Y 轴向上，Z 轴朝向屏幕外。")]),_._v(" "),v("h2",{attrs:{id:"_2-世界坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-世界坐标系"}},[_._v("#")]),_._v(" 2.世界坐标系")]),_._v(" "),v("p",[_._v("默认情况模型坐标系和世界坐标系重合。如果模型不在世界坐标系中心，那么就需要对模型进行坐标转换，将模型的各个相对于模型中心的顶点坐标转换成世界坐标系下的坐标。\n举个例子，假如模型中有一点 "),v("code",[_._v("P")]),_._v(" ，相对于模型中心的坐标"),v("code",[_._v("（1，1）")]),_._v("。 该模型在世界坐标系的"),v("code",[_._v("（3，0）")]),_._v("位置，那么，顶点 "),v("code",[_._v("P")]),_._v(" 在世界坐标系中的坐标就变成了"),v("code",[_._v("（4，1）")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"_3-视图坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-视图坐标系"}},[_._v("#")]),_._v(" 3.视图坐标系")]),_._v(" "),v("p",[_._v("又被称之为"),v("strong",[_._v("观察坐标系或者相机坐标系")]),_._v("，用于将世界坐标转化为用户视野前方的坐标。"),v("strong",[_._v("人眼或者摄像机")]),_._v("看到的世界中的物体相对于他自身的位置，所参照的坐标系就叫视图/观察坐标系。"),v("strong",[_._v("是以人眼/摄像机为原点而建立的坐标系")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"_4-裁剪坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-裁剪坐标系"}},[_._v("#")]),_._v(" 4.裁剪坐标系")]),_._v(" "),v("p",[_._v("将相机坐标进行"),v("strong",[_._v("投影变换")]),_._v("后得到的坐标，也就是 "),v("code",[_._v("gl_Position")]),_._v(" 接收的坐标。")]),_._v(" "),v("p",[_._v("相机坐标系观察的空间是整个 "),v("code",[_._v("3D")]),_._v(" 世界，而裁剪坐标系是希望所有的坐标都落在一个特定的范围内，超出这个范围的顶点坐标都将被裁剪掉，被裁剪掉的坐标就不会显示，这就是裁剪坐标系的由来。")]),_._v(" "),v("p",[_._v("这个特定的空间就是通过"),v("code",[_._v("投影矩阵")]),_._v("来创建的，投影矩阵会创建一个观察箱 "),v("code",[_._v("Viewing Box")]),_._v("，称为平截头体"),v("code",[_._v("Frustum")]),_._v("，出现在平截头体范围内的坐标最终都会显示在屏幕上。裁剪坐标系中的坐标转化到标准化设备坐标系的过程就很容易，这个过程被称之为投影"),v("code",[_._v("Projection")]),_._v("，")]),_._v(" "),v("p",[_._v("观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。")]),_._v(" "),v("h4",{attrs:{id:"_4-1正射投影矩阵"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1正射投影矩阵"}},[_._v("#")]),_._v(" 4.1正射投影矩阵：")]),_._v(" "),v("p",[_._v("又名正交投影，正射投影矩阵创建的是一个立方体的观察箱，它定义了一个裁剪空间，在该裁剪空间之外的坐标都会被丢弃。 正射投影矩阵需要指定观察箱的长度、宽度和高度。经过正射投影矩阵映射后的坐标 "),v("code",[_._v("w")]),_._v(" 分量不会改变，始终是 1，所以在经过透视除法后物体的轮廓比例不会发生改变，这种投影一般用在建筑施工图纸中，不符合人眼观察世界所产生的近大远小的规律。")]),_._v(" "),v("h4",{attrs:{id:"_4-2透视投影矩阵"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2透视投影矩阵"}},[_._v("#")]),_._v(" 4.2透视投影矩阵")]),_._v(" "),v("p",[_._v("透视投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外它还会修改每个顶点坐标的 "),v("code",[_._v("w")]),_._v(" 值，使得离人眼越远的物体的坐标 "),v("code",[_._v("w")]),_._v(" 值越大。被变换到裁剪空间的坐标都会在 "),v("code",[_._v("-w")]),_._v(" 到 "),v("code",[_._v("w")]),_._v(" 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。"),v("code",[_._v("WebGL")]),_._v(" 要求所有可见的坐标都落在"),v("code",[_._v("【-1.0 - 1.0】")]),_._v("范围内，因此，一旦坐标转换到裁剪空间，透视除法就会被应用到裁剪坐标上。透视投影需要设置"),v("strong",[_._v("近平面、远平面、透视深度")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"_5-ndc坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-ndc坐标系"}},[_._v("#")]),_._v(" 5.NDC坐标系")]),_._v(" "),v("p",[_._v("一旦所有顶点被变换到裁剪空间，"),v("code",[_._v("GPU")]),_._v(" 会对裁剪坐标执行"),v("strong",[_._v("透视除法")]),_._v("，在这个过程中 "),v("code",[_._v("GPU")]),_._v(" 会将顶点坐标的 "),v("code",[_._v("X，Y，Z")]),_._v(" 分量分别除以齐次 "),v("code",[_._v("W")]),_._v(" 分量。这一步会在每一个顶点着色器运行的最后被自动执行。最终所有坐标分量的范围都会在 "),v("code",[_._v("【-1，1】")]),_._v("之间，超出这个范围的坐标都将被 "),v("code",[_._v("GPU")]),_._v(" 丢弃。")]),_._v(" "),v("p",[v("strong",[_._v("NDC坐标系")]),_._v(" 采用的是左手坐标系，"),v("code",[_._v("Z")]),_._v(" 轴正向指向屏幕里面。")]),_._v(" "),v("p",[v("strong",[_._v("注意：")]),_._v(" 在 "),v("code",[_._v("NDC")]),_._v(" 坐标系中，默认情况，在不使用深度测试时，同一个位置后绘制的顶点会覆盖掉原来的顶点的颜色。从下面的两个例子中就可以得到答案。")]),_._v(" "),v("h2",{attrs:{id:"_6-屏幕坐标系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-屏幕坐标系"}},[_._v("#")]),_._v(" 6.屏幕坐标系")]),_._v(" "),v("p",[_._v("有了 "),v("code",[_._v("NDC")]),_._v(" 坐标之后，"),v("code",[_._v("GPU")]),_._v(" 会执行最后一步变换操作，视口变换，这个过程会将所有在"),v("code",[_._v("【-1, 1】")]),_._v("之间的坐标映射到屏幕空间中，并被变换成片段，也可以称之为像素。")]),_._v(" "),v("p",[v("strong",[_._v("总结：")]),_._v(" 因为我们更多的是关注"),v("strong",[_._v("模型变换、视图变换和投影变换")]),_._v("，所以更多的关注点放在前面四个坐标系上，后面的 "),v("code",[_._v("DNC")]),_._v("坐标系和"),v("code",[_._v("屏幕坐标系")]),_._v(" 不太被关注和提及。")]),_._v(" "),v("Valine")],1)}),[],!1,null,null,null);v.default=o.exports}}]);