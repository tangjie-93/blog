---
title: WebGL之深度缓冲区
date: '2024-06-13'
type: 技术
tags: WebGL
note: WebGL之深度缓冲区
---
## 1. 顶点的绘制顺序
在默认情况下，`WebGL`为了加速绘图操作，是按照顶点在缓冲区中的顺序来处理它们的。下面顶点数据。
```js
const verticesColors = new Float32Array([
    // Vertex coordinates and color
     0.0,  1.0,  -4.0,  0.4,  1.0,  0.4, // The back green one
    -0.5, -1.0,  -4.0,  0.4,  1.0,  0.4,
     0.5, -1.0,  -4.0,  1.0,  0.4,  0.4, 

     0.0,  1.0,  -2.0,  1.0,  1.0,  0.4, // The middle yellow one
    -0.5, -1.0,  -2.0,  1.0,  1.0,  0.4,
     0.5, -1.0,  -2.0,  1.0,  0.4,  0.4, 

     0.0,  1.0,   0.0,  0.4,  0.4,  1.0,  // The front blue one 
    -0.5, -1.0,   0.0,  0.4,  0.4,  1.0,
     0.5, -1.0,   0.0,  1.0,  0.4,  0.4, 
  ]);
```
按照绘制顺序 绿色的三角形在最下面，蓝色的三角形在最上面。如下图所示。
[实例 `demo` 地址](./demo/index1.html)
<img width='200' src='../../images/webgl/正常绘制1.png'>

当我们将顶点数据做如下修改时。
```js
  const verticesColors = new Float32Array([
    // Vertex coordinates and color
     0.0,  1.0,  2.0,  0.4,  1.0,  0.4, // The back green one
    -0.5, -1.0,  2.0,  0.4,  1.0,  0.4,
     0.5, -1.0,  2.0,  1.0,  0.4,  0.4, 

     0.0,  1.0,  1.0,  1.0,  1.0,  0.4, // The middle yellow one
    -0.5, -1.0,  1.0,  1.0,  1.0,  0.4,
     0.5, -1.0,  1.0,  1.0,  0.4,  0.4, 

     0.0,  1.0,   0.0,  0.4,  0.4,  1.0,  // The front blue one 
    -0.5, -1.0,   0.0,  0.4,  0.4,  1.0,
     0.5, -1.0,   0.0,  1.0,  0.4,  0.4, 
  ]);
```
绘制结果如下图所示。蓝色的三角形还是在上面

<img width='200' src='../../images/webgl/正常绘制2.png'>

[实例 `demo` 地址](./demo/index2.html)
这样看的可能还不太明显，我们可以将三角形进行一定角度的旋转。
```js
modelMatrix.setTranslate(0, 0, 0).setRotate(-10,0,1,0);
```
我们可以得到下面的渲染效果
<img src='../../images/webgl/正常绘制2-旋转.png'>
可以看到三角形是按照右手坐标系旋转了10度，那也就是按照左手坐标系旋转了-10度，同时也可以看出，绿色的三角形是在最下面的。这也证明了没有开启深度测试之前的是根据左手坐标系去绘制的。
## 2.隐藏面消除

为了解决这个问题，`WebGL`提供了**隐藏面清楚**的功能。这个功能的作用就是将那些被遮挡的面清除掉。开启隐藏面清除功能，需要遵循以下3个步骤。
#### 1.开启隐藏面清除功能。
```js
gl.enable(gl.DEPTH_TEST)。//开启深度测试
```
#### 2.在绘制之前，清除深度缓冲区。
```js
gl.clear(gl.DEPTH_BUFFER_BIT);
```
`WEbGL`在颜色缓冲区中绘制几何图形，绘制完成后将颜色缓冲区显示到`canvas`上。而深度缓冲区就是用来存储深度信息的。由于深度方向通常是`Z`轴方向，所以有时候我们也称之为`Z`轴缓冲区。

#### 3.必须正确设置可视空间，也就是进行投影变换
进行投影变换实际上是为了将坐标系转变称我们熟悉的右手坐标系，也就是`z`轴正向朝向屏幕外。

经过上面的三部曲操作后，绘制结果如下图所示：

<img width=200 src='../../images/webgl/深度测试.png'>

[实例 `demo` 地址](./demo/index3.html)

`gl.enable()`函数是用来开启`WebGL`中的多种功能的。一般有以下几个参数。
```js
gl.DEPTH_TEST:隐藏面清除
gl.BLEND: 混合
gl.POLYGON_OFFSET_FILL: 多边形位移
```

## 3.深度冲突

当几何图形的两个表面极为接近时，会出现问题，表面上看起来斑斑驳驳的，这种现象称之为**深度冲突**。下面我们来绘制两个`Z`值完全一致的三角形来进行测试。
`demo`地址 `./demo/zFight.html`
绘制结果如下所示：
<img width=200 src='../../images/webgl/深度冲突.png'>

`WebGL`为了解决这个问题，提供了一种**多边形偏移**的机制来解决这个问题。该机制将自动在`z`值上添加一个偏移量，偏移量的值由物体表面相对于观察者视线的角度来确定。启动该机制只需要两行代码。
+ 启用多边形偏移。
```js
gl.enable(gl.POLYGON_OFFSET_FILL)
```
+ 在绘制之前指定用来计算偏移量的参数。
```js
 gl.polygonOffset(1.0, 1.0) 
```
`gl.polygonOffset(factor, units) `偏移量按照公式`m*factor+r*units`计算，其中`m`表示顶点所在表面相对于观察者的视角的角度，而`r`表示硬件能够区分两个`z`值之差的最小值。
开启多边形偏移后的绘制结果如下所示。
<img width=200 src='../../images/webgl/深度冲突-解决方案.png'>

[`demo`地址 ](./demo/zFight.html)




<Valine></Valine>